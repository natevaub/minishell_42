
int	improved_dup2(int fildes, int fildes2)
{
	int	error;

	error = dup2(fildes, fildes2);
	if (error == -1)
	{
		perror("error dup2");
		exit(1);
	}
	return (error);
}

void	sub_dup2(int read, int write)
{
	improved_dup2(read, STDIN_FILENO);
	improved_dup2(write, STDOUT_FILENO);
}

int	improved_pipe(int fd[2])
{
	int	error;

	error = pipe(fd);
	if (error == -1)
	{
		perror("error pipe");
		exit(1);
	}
	return (error);
}

pid_t	improved_fork(void)
{
	pid_t	error;

	error = fork();
	if (error == -1)
	{
		perror("error fork");
		exit(1);
	}
	return (error);
}
extern t_global	global;

/*
	heredoc:
*/


int exec_pipe(t_minishell *ms, char **envp)
{
	t_lcmd	*curr;
	pid_t	pid;
	int		exit_status;
	int			pipe_fd[2][2];


	ms->p = malloc(sizeof(t_pipex));
	if (!ms->p)
		return (1);																	//set errno
	pipe(pipe_fd[0]);
	pipe(pipe_fd[1]);
	set_pipe_fds(ms);
	init_pipex_struct(ms);
	curr = ms->cmd;
		// printf("first command: %s\n", ms->cmd->cmd);
	printf("count_cmds: %d\n", ms->p->count_cmds);
	while (curr)
	{
		// curr = get_node_lcmd(ms->cmd, ms->p->idx);
		printf("cmd: %s & idx: %d \n", curr->cmd, ms->p->idx);
		pid = improved_fork();
		if (pid == 0)
		{
			run_cmd(curr, ms->p, envp);
		}
		ms->p->idx++;
		curr = curr->next;
	}
	close_pipes(ms->p);
	while (waitpid(-1, &exit_status, 0) > 0)
		;
	if (WIFEXITED(exit_status))
		global.last_exit_status = WEXITSTATUS(exit_status);

	return (global.last_exit_status);																//exits the program, why?
}

void	run_cmd(t_lcmd *cmd, t_pipex *p, char **envp)
{
	if (builtin_check(cmd->cmd) != 1)
	{
		child_exec(cmd, envp, p);
	}
	builtin_redirect(cmd);
}

//function creating fork for child & executing command
void	child_exec(t_lcmd *cmd, char **envp, t_pipex *p)
{
	char	*cmd_with_path;

		printf("before execve in child exec\n");
		sub_dup2(cmd->fd_read, cmd->fd_write);
		close_pipes(p);
		cmd_with_path = get_right_path(cmd->cmd);
		if (!cmd_with_path)
		{
			global.last_exit_status = 1;
		}
		if (execve(cmd_with_path, cmd->option, envp) < 0)
		{
			free(cmd_with_path);
			return (perror("Execve"));
		}
}


void	init_pipex_struct(t_minishell *ms)
{
	pipe(ms->p->pipe_fd[0]);
	pipe(ms->p->pipe_fd[1]);
	ms->p->count_cmds = total_len_cmd(ms->cmd);
	// printf("total len cmd: %d\n", ms->p->count_cmds);
	set_pipe_fds(ms);
	ms->p->idx = 0;

	// print_list_fds(ms->cmd);
}

//set command list & read/write fds
void	set_pipe_fds(t_minishell *ms)
{
	t_lcmd	*list;
	int		i;

	i = -1;
	list = ms->cmd;
	// printf("fd[0][0]: %d\nfd[0][1]: %d\nfd[1][0]: %d\nfd[1][1]: %d\n", ms->p->pipe_fd[0][0], ms->p->pipe_fd[0][1], ms->p->pipe_fd[1][0], ms->p->pipe_fd[1][1]);
	while (list && ++i < ms->p->count_cmds)
	{
		if (i == 0)
			list->fd_read = list->fd_read;
		else if (i % 2 != 0)
			list->fd_read = ms->p->pipe_fd[0][0];
		else
			list->fd_read = ms->p->pipe_fd[1][0];
		if (i == ms->p->count_cmds - 1)
			list->fd_write = list->fd_write;
		else if ((i % 2 == 0 || i == 0))
			list->fd_write = ms->p->pipe_fd[0][1];
		else
			list->fd_write = ms->p->pipe_fd[1][1];
		list = list->next;
	}
}


//append new node to t_lcmd command list, setting read & write fd
void	list_append_pipes(t_lcmd **lst, char *command, int w_pipe, int r_pipe)
{
	t_lcmd	*addback;
	t_lcmd	*copy;
	(void)	r_pipe;
	(void)	w_pipe;

	addback = (t_lcmd *)malloc(sizeof(t_lcmd));
	if (!addback)
		return ;
	addback->next = NULL;
	addback->option = ft_split(command, ' ');
	addback->cmd = addback->option[0];
	addback->fd_write = w_pipe;
	addback->fd_read = r_pipe;
	if (*lst == NULL)
	{
		*lst = addback;
		return ;
	}
	copy = last_node_pipes(*lst);
	copy->next = addback;
}

//go to last node of t_lcmd list
t_lcmd	*last_node_pipes(t_lcmd *lst)
{
	int	i;

	i = 0;
	while (lst->next)
		lst = lst->next;
	return (lst);
}

//get a node in the t_lcmd command list
t_lcmd	*get_node_lcmd(t_lcmd *head, int index)
{
	t_lcmd	*copy;
	int			i;

	i = 0;
	copy = head;
	while (i < index && copy != NULL)
	{
		copy = copy->next;
		i++;
	}
	return (copy);
}

//total len of linked command list
int	total_len_cmd(t_lcmd *commands)
{
	int	i;

	i = 0;
	while (commands)
	{
		commands = commands->next;
		i++;
	}
	return (i);
}

//print all fds for t_lcmd list
void	print_list_fds(t_lcmd *list)
{
	while (list)
	{
		printf("list fd read: %d and write %d\n", list->fd_read, list->fd_write);
		printf("list cmd: %s\n", list->cmd);
		list = list->next;
	}
	printf("\n");
}


//print error text & return to main
int	error(char *str)
{
	perror(str);
	return (-1);
}

//close all pipe ends except the one where we need to write to
void	close_pipes(t_pipex *pipex)
{
	close(pipex->pipe_fd[0][0]);
	close(pipex->pipe_fd[0][1]);
	close(pipex->pipe_fd[1][0]);
	close(pipex->pipe_fd[1][1]);
}



extern t_global	global;

//get entire text line following "PATH=" from envp
char	*get_path_line(void)
{
	char	*envp_path;
	t_venv	*head;

	head = global.copy_env;
	while (head)
	{
		if (ft_strncmp(head->word, "PATH", 4) == 0)
			envp_path = head->word;
		head = head->next;
	}
	return (envp_path + 5);
}

/*find the right path for a specific command (without parameters)
in order to pass it to envp in child/parent using access check function
(existing & executable)*/
char	*get_right_path(char *cmd)
{
	char	**all_paths;
	char	*temp_path;

	all_paths = ft_split(get_path_line(), ':');
	while (*all_paths)
	{
		temp_path = ft_join_path(*all_paths, cmd);
		if (access(temp_path, F_OK & X_OK) == 0)
			return (temp_path);
		free(temp_path);
		all_paths++;
	}
	return (NULL);
}


extern t_global	global;

//join two strings and add '/' at the end
char	*ft_join_path(char const *s1, char const *s2)
{
	char			*copy;
	int				i;
	int				j;
	unsigned int	len1;
	unsigned int	len2;

	len1 = ft_strlen(s1);
	len2 = ft_strlen(s2);
	i = 0;
	j = 0;
	copy = (char *)malloc(sizeof(*copy) * (len1 + len2 + 1));
	if (!copy)
		return (NULL);
	while (s1[i])
	{
		copy[i] = s1[i];
		i++;
	}
	copy[i++] = '/';
	while (s2[j])
		copy[i++] = s2[j++];
	copy[i] = '\0';
	return (copy);
}

char	**env_list_to_env_tab(void)
{
	char	**env;
	int		len;
	t_venv	*head;
	int		i;

	i = 0;
	head = global.copy_env;
	len = list_size(head);
	env = (char **)malloc (sizeof(char *) * (len + 1));
	while (head)
	{
		env[i] = ft_strdup(head->word);
		if (!env[i])
			return (NULL);															//set error msg
		i++;
		head = head->next;
	}
	env[i] = 0;

	return (env);
}